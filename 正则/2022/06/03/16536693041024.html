<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>知不知</title> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="theme-color" content="#157878"> <meta name="baidu-site-verification" content="" /> <meta name="apple-itunes-app" content="app-id=1227288468, app-argument=https://luowei.github.io/list/%E6%AD%A3%E5%88%99/2022/06/03/16536693041024.html"> <link rel="stylesheet" href="https://luowei.github.io/list/assets/css/normalize.css"> <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'> <link rel="stylesheet" href="https://luowei.github.io/list/assets/css/cayman.css"> </head> <body> <section class="page-header"> <h1 class="project-name">知不知</h1> <h2 class="project-tagline"><a style="color:#ffffff;" href="http://luowei.github.io/list">知不知</a> 是一个代码爱好者的技术知识分享部落格。</h2> <a href="http://wodedata.com" target="_blank" class="btn">wodedata</a> <a href="https://luowei.github.io/list" class="btn">home</a> <a href="http://app.wodedata.com" target="_blank" class="btn">APP作品</a> </section> <section class="main-content"> <!-- 标题 --> <h2>正则中的字符类、边界、可选项、量词</h2> <!-- Google Ads --> <script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8760692904992206" data-ad-slot="2948937366"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script></p> <h1 id="正则中的字符类边界可选项量词">正则中的字符类、边界、可选项、量词</h1> <p><strong>字符匹配</strong><br /> <code class="language-plaintext highlighter-rouge">[A-Za-z_][A-Za-z_0-9]*</code> 匹配编程语言的标识符；<br /> <code class="language-plaintext highlighter-rouge">0[xx][A-Fa-f0-9]+</code> 匹配一个C风格的十六进制数；<br /> <code class="language-plaintext highlighter-rouge">[^0-9\r\n]</code> 匹配除数字与换行符外的所有字符；<br /> <code class="language-plaintext highlighter-rouge">q[^u]</code> 匹配在 q 后不是字符 u 的字符串；<br /> <code class="language-plaintext highlighter-rouge">q(?!u)</code> 匹配在 q 后不是字符 u 的所有字符 q；</p> <p><strong>特殊符号</strong> <code class="language-plaintext highlighter-rouge">\Q*\d+*\E</code> 匹配 <code class="language-plaintext highlighter-rouge">*\d+*</code><br /> <code class="language-plaintext highlighter-rouge">(\Q*\d+*\E)+</code> 匹配 <code class="language-plaintext highlighter-rouge">*\d+**\d+*</code></p> <p>在绝大多数的正则风格里，方括号<code class="language-plaintext highlighter-rouge">]</code>中的只有：反斜杆<code class="language-plaintext highlighter-rouge">\</code>、插入符<code class="language-plaintext highlighter-rouge">^</code>、连字符<code class="language-plaintext highlighter-rouge">-</code> 这3种特殊字符需要转义，其他特殊字符都不需要额外转义. <code class="language-plaintext highlighter-rouge">[]x]</code> 匹配闭合方括号或x；<code class="language-plaintext highlighter-rouge">[^]x]</code> 匹配任意不是闭合方括号或x的字符； <code class="language-plaintext highlighter-rouge">[-x]</code>和<code class="language-plaintext highlighter-rouge">[x-]</code>匹配x或连字符；<code class="language-plaintext highlighter-rouge">[^-x]</code>和<code class="language-plaintext highlighter-rouge">[^x-]</code>匹配任意不是x或连字符的字符； <code class="language-plaintext highlighter-rouge">[.*$]</code> 匹配.号、*号、美元号；</p> <p><code class="language-plaintext highlighter-rouge">([0-9])\1+</code> 匹配重复数字；</p> <p><strong>字符类差集(仅XPath,.NET,JGsoft支持)</strong><br /> <code class="language-plaintext highlighter-rouge">[a-z-[aeiuo]]</code> 匹配一个辅音字符，等价于<code class="language-plaintext highlighter-rouge">[b-df-hj-np-tv-z]</code>； 嵌套： <code class="language-plaintext highlighter-rouge">[0-9-[0-6-[0-3]]]</code> 匹配 0123789，等价于<code class="language-plaintext highlighter-rouge">[0-37-9]</code>； <code class="language-plaintext highlighter-rouge">[^1234-[3456]]</code> 匹配 1,2,3,4,5,6 之外的所有数字；</p> <p><strong>字符类交集(仅Java,Ruby,JGsoft支持)</strong> <br /> <code class="language-plaintext highlighter-rouge">[a-z&amp;&amp;[^aeiuo]]</code> 匹配一个辅音字符，等价于<code class="language-plaintext highlighter-rouge">[b-df-hj-np-tv-z]</code>；<br /> 嵌套： <code class="language-plaintext highlighter-rouge">[^1234&amp;&amp;[3456]]</code> 匹配 5,6，等价于<code class="language-plaintext highlighter-rouge">[56]</code>； <br /> <code class="language-plaintext highlighter-rouge">[1234&amp;&amp;[^3456]]</code> 匹配 1,2，等价于<code class="language-plaintext highlighter-rouge">[12]</code>；</p> <p><strong>速记字符类</strong><br /> <code class="language-plaintext highlighter-rouge">\d</code> is short for [0-9];<br /> <code class="language-plaintext highlighter-rouge">\w</code> stands for “word character”, it always matches the ASCII characters <code class="language-plaintext highlighter-rouge">[A-Za-z0-9_]</code>;<br /> <code class="language-plaintext highlighter-rouge">\s</code> stands for “whitespace character”, it includes <code class="language-plaintext highlighter-rouge">[ \t\r\n\f]</code>;</p> <p><em>Negated Shorthand Character Classes</em><br /> <code class="language-plaintext highlighter-rouge">\D</code> is the same as <code class="language-plaintext highlighter-rouge">[^\d]</code>, <code class="language-plaintext highlighter-rouge">\W</code> is short for <code class="language-plaintext highlighter-rouge">[^\w]</code> and <code class="language-plaintext highlighter-rouge">\S</code> is the equivalent of <code class="language-plaintext highlighter-rouge">[^\s]</code>; <br /> <code class="language-plaintext highlighter-rouge">[\D\S]</code> is not the same as <code class="language-plaintext highlighter-rouge">[^\d\s]</code>, <code class="language-plaintext highlighter-rouge">[\D\S]</code> matches any character digit, whitespace, or otherwise ;</p> <p><code class="language-plaintext highlighter-rouge">\h</code> matches horizontal whitespace,which includes the tab and all characters in the “space separator” Unicode category;<br /> <code class="language-plaintext highlighter-rouge">\v</code> matches “vertical whitespace”, which includes all characters treated as line breaks in the Unicode standard, it is the same as <code class="language-plaintext highlighter-rouge">[\n\cK\f\r\x85\x{2028}\x{2029}]</code> ;</p> <p><strong>XML字符类(仅XML Schema,XPath，JGsoft V2支持)</strong> <code class="language-plaintext highlighter-rouge">\i</code> matches any character that may be the first character of an XML name. <br /> <code class="language-plaintext highlighter-rouge">\c</code> matches any character that may occur after the first character in an XML name. <br /> <code class="language-plaintext highlighter-rouge">\i\c*</code> matches an XML name like xml:schema. <code class="language-plaintext highlighter-rouge">&lt;\i\c*\s*&gt;</code> matches an opening XML tag without any attributes. <code class="language-plaintext highlighter-rouge">&lt;/\i\c*\s*&gt;</code> matches any closing tag. <code class="language-plaintext highlighter-rouge">&lt;\i\c*(\s+\i\c*\s*=\s*("[^"]*"|'[^']*'))*\s*&gt;</code> matches an opening tag with any number of attributes. <code class="language-plaintext highlighter-rouge">&lt;(\i\c*(\s+\i\c*\s*=\s*("[^"]*"|'[^']*'))*|/\i\c*)\s*&gt;</code> matches either an opening tag with attributes or a closing tag.</p> <p><strong>非XML支持的Regex flavors 匹配XML</strong> If XML files are plain ASCII ,can use <code class="language-plaintext highlighter-rouge">[_:A-Za-z]</code> for <code class="language-plaintext highlighter-rouge">\i</code> and <code class="language-plaintext highlighter-rouge">[-._:A-Za-z0-9]</code> for <code class="language-plaintext highlighter-rouge">\c</code>.</p> <p>If want to allow all Unicode characters that the XML standard allows. Instead of <code class="language-plaintext highlighter-rouge">\i</code> you would use: <code class="language-plaintext highlighter-rouge">[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]</code><br /> Instead of <code class="language-plaintext highlighter-rouge">\c</code> you would use: <code class="language-plaintext highlighter-rouge">[-.0-9:A-Z_a-z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]</code></p> <p><strong>Use The Dot Sparingly</strong> <br /> <code class="language-plaintext highlighter-rouge">[01]\d[- /.][0-3]\d[- /.]\d\d</code> matchs a date in mm/dd/yy format;<br /> <code class="language-plaintext highlighter-rouge">"[^"\r\n]*"</code> matches <code class="language-plaintext highlighter-rouge">"string"</code> which is proper than <code class="language-plaintext highlighter-rouge">".*"</code>;</p> <p><strong>Anchors</strong> <code class="language-plaintext highlighter-rouge">^\d+$</code> match the entire string must consist of digits; <code class="language-plaintext highlighter-rouge">^\s+</code> matches leading whitespace and <code class="language-plaintext highlighter-rouge">\s+$</code> matches trailing whitespace;</p> <p><code class="language-plaintext highlighter-rouge">\A</code> only ever matches at the start of the string. Likewise, <code class="language-plaintext highlighter-rouge">\Z</code> only ever matches at the end of the string. These two tokens never match at line breaks. POSIX regular expressions use <code class="language-plaintext highlighter-rouge">\`</code> (backtick) to match the start of the string, and <code class="language-plaintext highlighter-rouge">\'</code> (single quote) to match the end of the string.</p> <p><strong>Word Boundaries</strong><br /> The metacharacter <code class="language-plaintext highlighter-rouge">\b</code> is an anchor like the caret and the dollar sign. It matches at a position that is called a “word boundary”. This match is zero-length. <code class="language-plaintext highlighter-rouge">\b</code> allows you to perform a “whole words only” search using a regular expression in the form of <code class="language-plaintext highlighter-rouge">\bword\b</code>.<br /> <code class="language-plaintext highlighter-rouge">\w</code> are the characters that are treated as word characters by word boundaries. <code class="language-plaintext highlighter-rouge">\B</code> is the negated version of <code class="language-plaintext highlighter-rouge">\b</code>. <code class="language-plaintext highlighter-rouge">\B</code> matches at any position between two word characters as well as at any position between two non-word characters.<br /> Besides,GNU also uses its own syntax for start-of-word and end-of-word boundaries. <code class="language-plaintext highlighter-rouge">\&lt;</code> matches at the start of a word, like Tcl’s <code class="language-plaintext highlighter-rouge">\m</code>. <code class="language-plaintext highlighter-rouge">\&gt;</code> matches at the end of a word, like Tcl’s <code class="language-plaintext highlighter-rouge">\M</code>.<br /> The POSIX standard defines <code class="language-plaintext highlighter-rouge">[[:&lt;:]]</code> as a start-of-word boundary, and <code class="language-plaintext highlighter-rouge">[[:&gt;:]]</code> as an end-of-word boundary.</p> <p><strong>Optional Items</strong><br /> <code class="language-plaintext highlighter-rouge">colou?r</code> matches both <code class="language-plaintext highlighter-rouge">colour</code> and <code class="language-plaintext highlighter-rouge">color</code>.<br /> <code class="language-plaintext highlighter-rouge">Nov(ember)?</code> matches <code class="language-plaintext highlighter-rouge">Nov</code> and <code class="language-plaintext highlighter-rouge">November</code>.</p> <p>You can also use curly braces to make something optional. <code class="language-plaintext highlighter-rouge">colou{0,1}r</code> is the same as <code class="language-plaintext highlighter-rouge">colou?r</code>.</p> <p>If you apply the regex <code class="language-plaintext highlighter-rouge">Feb 23(rd)?</code> to the string <code class="language-plaintext highlighter-rouge">Today is Feb 23rd, 2003</code>, the match is always <code class="language-plaintext highlighter-rouge">Feb 23rd</code> and not <code class="language-plaintext highlighter-rouge">Feb 23</code>. You can make the question mark lazy (i.e. turn off the greediness) by putting a second question mark after the first <code class="language-plaintext highlighter-rouge">Feb 23(rd)??</code>.</p> <p><strong>非打印字符</strong> Use <code class="language-plaintext highlighter-rouge">\t</code> to match a tab character (ASCII 0x09), <code class="language-plaintext highlighter-rouge">\r</code> for carriage return (0x0D) and <code class="language-plaintext highlighter-rouge">\n</code> for line feed (0x0A). More exotic non-printables are <code class="language-plaintext highlighter-rouge">\a</code> (bell, 0x07), <code class="language-plaintext highlighter-rouge">\e</code> (escape, 0x1B), and <code class="language-plaintext highlighter-rouge">\f</code> (form feed, 0x0C). Remember that Windows text files use <code class="language-plaintext highlighter-rouge">\r\n</code> to terminate lines, while UNIX text files use <code class="language-plaintext highlighter-rouge">\n</code>.</p> <p>In some flavors, <code class="language-plaintext highlighter-rouge">\v</code> matches the vertical tab (ASCII 0x0B). In other flavors, <code class="language-plaintext highlighter-rouge">\v</code> is a shorthand that matches any vertical whitespace character.</p> <p>In the Latin-1 character set, the copyright symbol is character 0xA9. So to search for the copyright symbol, you can use <code class="language-plaintext highlighter-rouge">\xA9</code>.</p> <p><code class="language-plaintext highlighter-rouge">\R</code> is a special escape that matches any line break, including Unicode line breaks, so <code class="language-plaintext highlighter-rouge">\R</code> can also match a lone CR or a lone LF.</p> <p><strong>Unicode字符</strong><br /> 可以使用 <code class="language-plaintext highlighter-rouge">\uFFFF</code> 或 <code class="language-plaintext highlighter-rouge">\x{FFFF}</code> 插入 Unicode 字符；<br /> <code class="language-plaintext highlighter-rouge">\x{00E0}</code> 匹配 <code class="language-plaintext highlighter-rouge">à</code>，<code class="language-plaintext highlighter-rouge">\x{0061}</code> 匹配 <code class="language-plaintext highlighter-rouge">a</code>；</p> <p>You can match a single character belonging to the “letter” category with <code class="language-plaintext highlighter-rouge">\p{L}</code>. You can match a single character not belonging to that category with <code class="language-plaintext highlighter-rouge">\P{L}</code>.</p> <p>Reference from:<a href="https://luowei.github.io/list/https://www.regular-expressions.info/unicode.html">https://www.regular-expressions.info/unicode.html</a></p> <p><strong>Mode Modifiers</strong> you can add the following mode modifiers to the start of the regex. To specify multiple modes, simply put them together as in <code class="language-plaintext highlighter-rouge">(?ismx)</code>.</p> <p><code class="language-plaintext highlighter-rouge">(?i)</code> makes the regex case insensitive. <code class="language-plaintext highlighter-rouge">(?x)</code> turn on free-spacing mode. <code class="language-plaintext highlighter-rouge">(?xx)</code> turn on free-spacing mode, also in character classes. <code class="language-plaintext highlighter-rouge">(?s)</code> for “single line mode” makes the dot match all characters, including line breaks. <code class="language-plaintext highlighter-rouge">(?m)</code> for “multi-line mode” makes the caret and dollar match at the start and end of each line in the subject string, <code class="language-plaintext highlighter-rouge">(?m)</code> also prevents the dot from matching line breaks.</p> <p>you can turn off modes by preceding them with a minus sign. All modes after the minus sign will be turned off. E.g. <code class="language-plaintext highlighter-rouge">(?i-sm)</code> turns on case insensitivity, and turns off both single-line mode and multi-line mode. The regex <code class="language-plaintext highlighter-rouge">(?i)te(?-i)st</code> should match <code class="language-plaintext highlighter-rouge">test</code> and <code class="language-plaintext highlighter-rouge">TEst</code>, but not <code class="language-plaintext highlighter-rouge">teST</code> or <code class="language-plaintext highlighter-rouge">TEST</code>.</p> <p>Instead of using two modifiers, one to turn an option on, and one to turn it off, you use a modifier span. <code class="language-plaintext highlighter-rouge">(?i)caseless(?-i)cased(?i)caseless</code> is equivalent to <code class="language-plaintext highlighter-rouge">(?i)caseless(?-i:cased)caseless</code> which match <code class="language-plaintext highlighter-rouge">CaseLESScasedCASELess</code>. This syntax resembles that of the non-capturing group (?:group).</p> <p><strong>所有格量词(Possessive Quantifiers)</strong> 因为所有格量词不必记住任何回溯位置，所有格量词性能远高于非所有格量词，可以通过在其后放置一个额外的 <code class="language-plaintext highlighter-rouge">+</code> 来使量词具有所有格。 <code class="language-plaintext highlighter-rouge">*</code> 是贪婪的，<code class="language-plaintext highlighter-rouge">*?</code> 是懒惰的， <code class="language-plaintext highlighter-rouge">*+</code> 是所有格。 <code class="language-plaintext highlighter-rouge">++</code>、<code class="language-plaintext highlighter-rouge">?+</code> 和 <code class="language-plaintext highlighter-rouge">{n,m}+</code> 也是所有格。</p> <p><code class="language-plaintext highlighter-rouge">"[^"]*+"</code> 匹配 <code class="language-plaintext highlighter-rouge">"abc"</code><br /> 使用所有格量词可能改变匹配尝试的结果，比如 <code class="language-plaintext highlighter-rouge">".*"</code> 匹配 <code class="language-plaintext highlighter-rouge">"abc"x</code>， 但 <code class="language-plaintext highlighter-rouge">".*+" </code> 不能匹配 <code class="language-plaintext highlighter-rouge">"abc"x</code></p> <p><strong>使用原子分组代替所有格量词</strong> <br /> 基本上，用 <code class="language-plaintext highlighter-rouge">(?&gt;X*)</code> 代替 <code class="language-plaintext highlighter-rouge">X*+</code>；<code class="language-plaintext highlighter-rouge">(?:a|b)*+</code> 等价于 <code class="language-plaintext highlighter-rouge">(?&gt;(?:a|b)*)</code> 但不等价于 <code class="language-plaintext highlighter-rouge">(?&gt;a|b)*</code>；<code class="language-plaintext highlighter-rouge">(?:a|b)*+b</code> 和 <code class="language-plaintext highlighter-rouge">(?&gt;(?:a|b)*)b</code> 都无法匹配 <code class="language-plaintext highlighter-rouge">b</code>， <code class="language-plaintext highlighter-rouge">a|b</code> 匹配 <code class="language-plaintext highlighter-rouge">b</code>，另外 <code class="language-plaintext highlighter-rouge">(?&gt;a|b)*b</code> 可以匹配 <code class="language-plaintext highlighter-rouge">b</code>。 在正则表达式 <code class="language-plaintext highlighter-rouge">(?&gt;a|b)*b</code> 中，原子组强制交替放弃其回溯位置。 这意味着如果 <code class="language-plaintext highlighter-rouge">a</code> 匹配，如果正则表达式的其余部分失败，它将不会返回尝试 <code class="language-plaintext highlighter-rouge">b</code>。 由于这<code class="language-plaintext highlighter-rouge">*</code>在组外，它是一个正常的、贪婪的<code class="language-plaintext highlighter-rouge">*</code>。 当第二个 <code class="language-plaintext highlighter-rouge">b</code> 失败时，贪心<code class="language-plaintext highlighter-rouge">*</code>回溯到 0 迭代。 然后，第二个 <code class="language-plaintext highlighter-rouge">b</code> 匹配主题字符串中的 <code class="language-plaintext highlighter-rouge">b</code>。</p> <p><strong>Branch Reset Groups</strong><br /> The syntax is <code class="language-plaintext highlighter-rouge">(?|regex)</code> where <code class="language-plaintext highlighter-rouge">(?|</code> opens the group and <code class="language-plaintext highlighter-rouge">regex</code> is any regular expression.</p> <p>The regex <code class="language-plaintext highlighter-rouge">(?|(a)|(b)|(c))</code> consists of a single branch reset group with three alternatives. This regex matches either <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, or <code class="language-plaintext highlighter-rouge">c</code>. The regex has only a single capturing group with number 1 that is shared by all three alternatives. After the match, $1 holds <code class="language-plaintext highlighter-rouge">a</code>, <code class="language-plaintext highlighter-rouge">b</code>, or <code class="language-plaintext highlighter-rouge">c</code>. such as <code class="language-plaintext highlighter-rouge">(?|(a)|(b)|(c))\1</code> matches <code class="language-plaintext highlighter-rouge">aa</code>, <code class="language-plaintext highlighter-rouge">bb</code>, or <code class="language-plaintext highlighter-rouge">cc</code>.</p> <p>The alternatives in the branch reset group don’t need to have the same number of capturing groups. <code class="language-plaintext highlighter-rouge">(?|abc|(d)(e)(f)|g(h)i)</code> has three capturing groups. When this regex matches <code class="language-plaintext highlighter-rouge">abc</code>, all three groups are empty. When <code class="language-plaintext highlighter-rouge">def</code> is matched, <code class="language-plaintext highlighter-rouge">$1</code> holds <code class="language-plaintext highlighter-rouge">d</code>, <code class="language-plaintext highlighter-rouge">$2</code> holds <code class="language-plaintext highlighter-rouge">e</code> and <code class="language-plaintext highlighter-rouge">$3</code> holds <code class="language-plaintext highlighter-rouge">f</code>. When <code class="language-plaintext highlighter-rouge">ghi</code> is matched, <code class="language-plaintext highlighter-rouge">$1</code> holds <code class="language-plaintext highlighter-rouge">h</code> overrided while the other two are empty.</p> <p><code class="language-plaintext highlighter-rouge">(x)(?|abc|(d)(e)(f)|g(h)i)(y)</code> defines five capturing groups. <code class="language-plaintext highlighter-rouge">(x)</code> is group 1, <code class="language-plaintext highlighter-rouge">(d)</code> and <code class="language-plaintext highlighter-rouge">(h)</code> are group 2, <code class="language-plaintext highlighter-rouge">(e)</code> is group 3, <code class="language-plaintext highlighter-rouge">(f)</code> is group 4, and <code class="language-plaintext highlighter-rouge">(y)</code> is group 5.</p> <p><code class="language-plaintext highlighter-rouge">(?'before'x)(?|abc|(?'left'd)(?'middle'e)(?'right'f)|g(?'left'h)i)(?'after'y)</code> is the same as the previous regex. It names the five groups “before”, “left”, “middle”, “right”, and “after”. Notice that because the 3rd alternative has only one capturing group, that must be the name of the first group in the other alternatives.</p> <p>If you omit the names in some alternatives, the groups will still share the names with the other alternatives. In the regex <code class="language-plaintext highlighter-rouge">(?'before'x)(?|abc|(?'left'd)(?'middle'e)(?'right'f)|g(h)i)(?'after'y)</code> the group <code class="language-plaintext highlighter-rouge">(h)</code> is still named “left” because the branch reset group makes it share the name and number of <code class="language-plaintext highlighter-rouge">(?'left'd)</code>.</p> <p><strong>Free-Spacing Regular Expressions</strong> <br /> you can put <code class="language-plaintext highlighter-rouge">(?x)</code> the very start of the regex to make the remainder of the regex free-spacing.<br /> In free-spacing mode, whitespace between regular expression tokens is ignored. Whitespace includes spaces, tabs, and line breaks. <code class="language-plaintext highlighter-rouge">a b c</code> is the same as <code class="language-plaintext highlighter-rouge">abc</code> in free-spacing mode. But <code class="language-plaintext highlighter-rouge">\ d</code> and <code class="language-plaintext highlighter-rouge">\d</code> are not the same. <br /> Likewise, grouping modifiers cannot be broken up. <code class="language-plaintext highlighter-rouge">(?&gt;atomic)</code> is the same as <code class="language-plaintext highlighter-rouge">(?&gt; ato mic )</code> and as <code class="language-plaintext highlighter-rouge">( ?&gt;ato mic)</code>. They all match the same atomic group. <br /> The <code class="language-plaintext highlighter-rouge">?&gt;</code> grouping modifier is a single element in the regex syntax, and must stay together. <br /> Perl 5.26 and PCRE 10.30 also add a new mode modifier <code class="language-plaintext highlighter-rouge">(?xx)</code> which enables free-spacing both inside and outside character classes. <code class="language-plaintext highlighter-rouge">(?x)</code> turns on free-spacing outside character classes like before, but also turns off free-spacing inside character classes. <code class="language-plaintext highlighter-rouge">(?-x)</code> and <code class="language-plaintext highlighter-rouge">(?-xx)</code> both completely turn off free-spacing.</p> <p><span class="site-footer-credits">版权所有，转载请注明出处 <a href="https://luowei.github.io/list">luowei.github.io</a>.</span></p> <link rel="stylesheet" href="/list/assets/css/font-awesome.min.css?ver=20151122" /> <!--[if IE 7 ]><link rel="stylesheet" href="/list/assets/css/font-awesome-ie7.min.css?ver=20151122"><![endif]--> <div style="float: right"> <span id="share"> <a class="wechat" target="_blank" title="分享到微信" href="https://chart.apis.google.com/chart?cht=qr&amp;chs=300x300&amp;chl=https%3A%2F%2Fluowei.github.io%2Flist%2F%25E6%25AD%25A3%25E5%2588%2599%2F2022%2F06%2F03%2F16536693041024.html"><i class="icon-large icon-wechat"></i></a> <a class="weibo" target="_blank" title="分享到微博" href="http://service.weibo.com/share/share.php?title=正则中的字符类、边界、可选项、量词 - 知不知&amp;url=https%3A%2F%2Fluowei.github.io%2Flist%2F%25E6%25AD%25A3%25E5%2588%2599%2F2022%2F06%2F03%2F16536693041024.html&amp;type=3&amp;searchPic=1"><i class="icon-large icon-weibo"></i></a> <a class="qzone" target="_blank" title="分享到 QQ 空间" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https%3A%2F%2Fluowei.github.io%2Flist%2F%25E6%25AD%25A3%25E5%2588%2599%2F2022%2F06%2F03%2F16536693041024.html&amp;title=正则中的字符类、边界、可选项、量词 - 知不知&amp;summary=正则中的字符类、边界、可选项、量词&amp;site=/list"><i class="icon-large icon-qzone"></i></a> <a class="twitter" target="_blank" title="Share to Twitter" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fluowei.github.io%2Flist%2F%25E6%25AD%25A3%25E5%2588%2599%2F2022%2F06%2F03%2F16536693041024.html&amp;text=正则中的字符类、边界、可选项、量词 - 知不知&amp;via=luowei010101"><i class="icon-large icon-twitter"></i></a> <a class="facebook" target="_blank" title="Share to Facebook" href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Fluowei.github.io%2Flist%2F%25E6%25AD%25A3%25E5%2588%2599%2F2022%2F06%2F03%2F16536693041024.html&amp;t=正则中的字符类、边界、可选项、量词 - 知不知"><i class="icon-large icon-facebook-sign"></i></a> <a class="googleplus" target="_blank" title="Share to Google+" href="https://plus.google.com/share?url=https%3A%2F%2Fluowei.github.io%2Flist%2F%25E6%25AD%25A3%25E5%2588%2599%2F2022%2F06%2F03%2F16536693041024.html"><i class="icon-large icon-google-plus-sign"></i></a> </span> </div> <hr /> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" /> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <div id="gitalk-container"></div> <script type="text/javascript"> var gitalk = new Gitalk({ clientID: '9d5ee666269c252cf949', clientSecret: '728cd598f1fca9d8c1df1dfa300057883a3a8676', repo: 'list', owner: 'luowei', admin: ['luowei'], id: decodeURI('正则中的字符类、边界、可选项、量词'), distractionFreeMode: false }); gitalk.render('gitalk-container'); </script> <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277627361'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s96.cnzz.com/z_stat.php%3Fid%3D1277627361%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script> <footer class="site-footer"> <span class="site-footer-owner"><a href="https://luowei.github.io/list">知不知</a> is maintained by <a href="http://luowei.github.io/list">luowei</a>.</span> <span class="site-footer-credits">Developed by <a href="https://luowei.github.io/list">luowei</a>.</span> </footer> </section> </body> </html>
