<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>知不知</title> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="theme-color" content="#157878"> <link rel="stylesheet" href="/list/assets/css/normalize.css"> <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'> <link rel="stylesheet" href="/list/assets/css/cayman.css"> </head> <body> <section class="page-header"> <h1 class="project-name">知不知</h1> <h2 class="project-tagline"><a style="color:#ffffff;" href="http://luowei.github.io/list">知不知</a> 是一个代码爱好者的技术知识分享部落格。</h2> <a href="http://wodedata.com" target="_blank" class="btn">wodedata</a> <a href="/list" class="btn">home</a> <a href="http://app.wodedata.com" target="_blank" class="btn">APP作品</a> </section> <section class="main-content"> <!-- 标题 --> <h2>HTTPS的深入理解</h2> <!-- Google Ads --> <script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8760692904992206" data-ad-slot="2948937366"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script></p> <h2 id="https的工作原理">HTTPS的工作原理</h2> <ul> <li>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL协议不仅仅是一套加密传输的协议，更是一件经过艺术家精心设计的艺术品，TLS/SSL中使用了非对称加密，对称加密以及HASH算法。握手过程的具体描述如下：</li> </ul> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 浏览器将自己支持的一套加密规则发送给网站。 
2. 网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。 
3. 浏览器获得网站证书之后浏览器要做以下工作： 
    a.验证证书的合法性（颁发证书的机构是否合法，证书中包含的网站地址是否与正在访问的地址一致等），如果证书受信任，则浏览器栏里面会显示一个小锁头，否则会给出证书不受信的提示。 
    b.如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密。 
    c.使用约定好的HASH算法计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站。 
4. 网站接收浏览器发来的数据之后要做以下的操作： 
    a.使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。 
    b.使用密码加密一段握手消息，发送给浏览器。 
5.浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。
</code></pre></div></div> <ul> <li>这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。另外，HTTPS一般使用的加密与HASH算法如下：</li> </ul> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 非对称加密算法：RSA，DSA/DSS 
 对称加密算法：AES，RC4，3DES 
 HASH算法：MD5，SHA1，SHA256
</code></pre></div></div> <ul> <li> <p>HTTPS对应的通信时序图如下： <img src="http://ww2.sinaimg.cn/large/680dfa44jw1faniowa4rwj208v09mdg9.jpg" alt="时序图" /></p> </li> <li> <p>HTTPS协议和HTTP协议的区别：</p> <ul> <li>https协议需要到ca申请证书，一般免费证书很少，需要交费。</li> <li>http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li> <li>http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。</li> <li>http的连接很简单,是无状态的 。</li> <li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议， 要比http协议安全。</li> </ul> </li> </ul> <h2 id="与https相关的几个常见的安全问题">与HTTPS相关的几个常见的安全问题</h2> <h3 id="csrf">CSRF</h3> <ul> <li>CSRF(跨站请求伪造，Cross-Site Request Forgery简称)，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：<code class="highlighter-rouge">简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的</code>。</li> <li> <p>案例： 假如一家银行用以执行转账操作的URL地址如下： <code class="highlighter-rouge">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</code></p> <p>那么，一个恶意攻击者可以在另一个网站上放置如下代码： <code class="highlighter-rouge">&lt;img src="http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman"&gt;</code></p> <p>如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。</p> <p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p> <p>透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。</p> </li> <li>防御措施 <ul> <li> <p>检查Referer字段</p> <p>HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问。</p> <p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。</p> </li> <li> <p>添加校验token</p> <p>由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行CSRF攻击。<code class="highlighter-rouge">这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。</code>正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验token的值为空或者错误，拒绝这个可疑请求。(同Cookie Hashing)</p> </li> <li> <p>验证码 这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，这个方案可以完全解决CSRF，但在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，可能在某些版本的微软IE中受影响。</p> </li> </ul> </li> </ul> <h3 id="中间人攻击">中间人攻击</h3> <ul> <li> <p>SSL证书欺骗攻击 此类攻击较为简单常见。首先通过ARP欺骗、DNS劫持甚至网关劫持等等，将客户端的访问重定向到攻击者的机器，让客户端机器与攻击者机器建立HTTPS连接（使用伪造证书），而攻击者机器再跟服务端连接。这样用户在客户端看到的是相同域名的网站，但浏览器会提示证书不可信，用户不点击继续浏览就能避免被劫持的。所以这是最简单的攻击方式，也是最容易识别的攻击方式。</p> <ul> <li> <p>防范措施：</p> <p>钓鱼类攻击，App直接调用系统API创建的HTTPS连接(NSURLConnection)一般不会受到影响，只使用默认的系统校验，只要系统之前没有信任相关的伪造证书，校验就直接失败，不会SSL握手成功；但如果是使用WebView浏览网页，需要在UIWebView中加入较强的授权校验，禁止用户在校验失败的情况下继续访问。</p> </li> </ul> </li> <li> <p>SSL剥离攻击（SSLStrip） SSL剥离，即将HTTPS连接降级到HTTP连接。</p> <p>该攻击方式主要是利用用户并不会每次都直接在浏览器上输入<code class="highlighter-rouge">https://xxx.xxx.com</code>来访问网站，或者有些网站并非全网HTTPS，而是只在需要进行敏感数据传输时才使用HTTPS的漏洞。中间人攻击者在劫持了客户端与服务端的HTTP会话后，将HTTP页面里面所有的<code class="highlighter-rouge">https://</code>超链接都换成<code class="highlighter-rouge">http://</code>，用户在点击相应的链接时，是使用HTTP协议来进行访问；这样，就算服务器对相应的URL只支持HTTPS链接，但中间人一样可以和服务建立HTTPS连接之后，将数据使用HTTP协议转发给客户端，实现会话劫持。</p> <p>这种攻击手段更让人难以提防，因为它使用HTTP，不会让浏览器出现HTTPS证书不可信的警告，而且用户很少会去看浏览器上的URL是<code class="highlighter-rouge">https://</code>还是<code class="highlighter-rouge">http://</code>。特别是App的WebView中，应用一般会把URL隐藏掉，用户根本无法直接查看到URL出现异常。</p> <ul> <li> <p>防范措施：</p> <p>该种攻击方式同样无法劫持App内的HTTPS连接会话，因为App中传入请求的URL参数是固定带有<code class="highlighter-rouge">https://</code>的；但在WebView中打开网页同样需要注意，在非全网HTTPS的网站，建议对WebView中打开的URL做检查，检查应该使用<code class="highlighter-rouge">https://</code>的URL是否被篡改为<code class="highlighter-rouge">http://</code>；也建议服务端在配置HTTPS服务时，加上“HTTP Strict Transport Security”配置项。</p> </li> </ul> </li> <li> <p>针对SSL算法进行攻击</p> <p>上述两种方式，技术含量较低，而且一般只能影响 WebApp，而很难攻击到 Native App ， 所以高阶的 Hacker，会直接针对SSL算法相关漏洞进行攻击，期间会使用很多的密码学相关手段。</p> <ul> <li> <p>防范措施：</p> <p>这类攻击手段是利用SSL算法的相关漏洞，所以最好的防范措施就是对服务端 SSL/TLS 的配置进行升级：</p> <ul> <li>只支持尽量高版本的TLS（最低TLSv1）；</li> <li>禁用一些已爆出安全隐患的加密方法；</li> <li>使用2048位的数字证书；</li> </ul> </li> </ul> </li> </ul> <h3 id="实现支持https">实现支持HTTPS</h3> <ul> <li>使用NSURLConnection支持HTTPS的实现</li> </ul> <p>以下通过系统默认验证流程来验证证书：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Now start the connection
NSURL * httpsURL = [NSURL URLWithString:@"https://www.google.com"];
self.connection = [NSURLConnection connectionWithRequest:[NSURLRequest requestWithURL:httpsURL] delegate:self];

    
//回调
- (void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge {
    //1)获取trust object
    SecTrustRef trust = challenge.protectionSpace.serverTrust;
    SecTrustResultType result;
    
    //2)SecTrustEvaluate对trust进行验证
    OSStatus status = SecTrustEvaluate(trust, &amp;result);
    if (status == errSecSuccess &amp;&amp;
        (result == kSecTrustResultProceed ||
        result == kSecTrustResultUnspecified)) {
        
        //3)验证成功，生成NSURLCredential凭证cred，告知challenge的sender使用这个凭证来继续连接
        NSURLCredential *cred = [NSURLCredential credentialForTrust:trust];
        [challenge.sender useCredential:cred forAuthenticationChallenge:challenge];
        
    } else {
    
        //5)验证失败，取消这次验证流程
        [challenge.sender cancelAuthenticationChallenge:challenge];
        
  }
}
</code></pre></div></div> <p>如果是我们自建的证书，Trust Object里面服务器的证书因为不是可信任的CA签发的，所以直接使用SecTrustEvaluate进行验证是不会成功。又或者，即使服务器返回的证书是信任CA签发的，又如何确定这证书就是我们想要的特定证书？这就需要先在本地导入证书，设置成需要参与验证的Anchor Certificate（锚点证书，通过SecTrustSetAnchorCertificates设置了参与校验锚点证书之后，假如验证的数字证书是这个锚点证书的子节点，即验证的数字证书是由锚点证书对应CA或子CA签发的，或是该证书本身，则信任该证书），再调用SecTrustEvaluate来验证。代码如下：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//先导入证书
NSString * cerPath = ...; //证书的路径
NSData * cerData = [NSData dataWithContentsOfFile:cerPath];
SecCertificateRef certificate = SecCertificateCreateWithData(NULL, (__bridge CFDataRef)(cerData));
self.trustedCertificates = @[CFBridgingRelease(certificate)];

//回调
- (void)connection:(NSURLConnection *)connection willSendRequestForAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge {
    //1)获取trust object
    SecTrustRef trust = challenge.protectionSpace.serverTrust;
    SecTrustResultType result;

    //注意：这里将之前导入的证书设置成下面验证的Trust Object的anchor certificate
    SecTrustSetAnchorCertificates(trust, (__bridge CFArrayRef)self.trustedCertificates);

    //2)SecTrustEvaluate会查找前面SecTrustSetAnchorCertificates设置的证书或者系统默认提供的证书，对trust进行验证
    OSStatus status = SecTrustEvaluate(trust, &amp;result);
    if (status == errSecSuccess &amp;&amp;
        (result == kSecTrustResultProceed ||
        result == kSecTrustResultUnspecified)) {
        
        //3)验证成功，生成NSURLCredential凭证cred，告知challenge的sender使用这个凭证来继续连接
        NSURLCredential *cred = [NSURLCredential credentialForTrust:trust];
        [challenge.sender useCredential:cred forAuthenticationChallenge:challenge];
        
    } else {
    
        //5)验证失败，取消这次验证流程
        [challenge.sender cancelAuthenticationChallenge:challenge];
        
  }
}
</code></pre></div></div> <ul> <li> <p>使用AFNetworking来支持HTTPS</p> <p>AFNetworking是iOS/OSX开发最流行的第三方开源库之一，其作者是非常著名的iOS/OSX开发者Mattt Thompson，其博客NSHipster也是iOS/OSX开发者学习和开阔技术视野的好地方。AFNetworking已经将上面的逻辑代码封装好，甚至更完善，在AFSecurityPolicy文件中，有兴趣可以阅读这个模块的代码。AFNetworking上配置对HTTPS的支持非常简单，AFHTTPSessionManager与之基本一致。如下代码：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  NSURL * url = [NSURL URLWithString:@"https://www.google.com"];
  AFHTTPRequestOperationManager * requestOperationManager = [[AFHTTPRequestOperationManager alloc] initWithBaseURL:url];
  dispatch_queue_t requestQueue = dispatch_create_serial_queue_for_name("kRequestCompletionQueue");
  requestOperationManager.completionQueue = requestQueue;
    
  AFSecurityPolicy * securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];
    
  //allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO
  //如果是需要验证自建证书，需要设置为YES
  securityPolicy.allowInvalidCertificates = YES;
    
  //validatesDomainName 是否需要验证域名，默认为YES；
  //假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。
  //置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。
  //如置为NO，建议自己添加对应域名的校验逻辑。
  securityPolicy.validatesDomainName = YES;
    
  //validatesCertificateChain 是否验证整个证书链，默认为YES
  //设置为YES，会将服务器返回的Trust Object上的证书链与本地导入的证书进行对比，这就意味着，假如你的证书链是这样的：
  //GeoTrust Global CA 
  //    Google Internet Authority G2
  //        *.google.com
  //那么，除了导入*.google.com之外，还需要导入证书链上所有的CA证书（GeoTrust Global CA, Google Internet Authority G2）；
  //如是自建证书的时候，可以设置为YES，增强安全性；假如是信任的CA所签发的证书，则建议关闭该验证，因为整个证书链一一比对是完全没有必要（请查看源代码）；
  securityPolicy.validatesCertificateChain = NO;
    
  requestOperationManager.securityPolicy = securityPolicy;
</code></pre></div> </div> </li> </ul> <hr /> <p>以上参考： <a href="http://www.cnblogs.com/ttltry-air/archive/2012/08/20/2647898.html">HTTPS的工作原理</a></p> <p><a href="http://oncenote.com/2014/10/21/Security-1-HTTPS/">iOS安全系列之一：HTTPS</a> <a href="http://oncenote.com/2015/09/16/Security-2-HTTPS2/">iOS安全系列之二：HTTPS进阶</a></p> <p><a href="http://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html?login=1">浅谈CSRF攻击方式</a></p> <p><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">跨站请求伪造</a></p> <p><a href="https://software.intel.com/zh-cn/blogs/2011/10/11/ssl">针对SSL的中间人攻击</a></p> <p><span class="site-footer-credits">版权所有，转载请注明出处 <a href="https://luowei.github.io/list">luowei.github.io</a>.</span></p> <link rel="stylesheet" href="/list/assets/css/font-awesome.min.css?ver=20151122" /> <!--[if IE 7 ]><link rel="stylesheet" href="/list/assets/css/font-awesome-ie7.min.css?ver=20151122"><![endif]--> <div style="float: right"> <span id="share"> https://luowei.github.io/list <a class="wechat" target="_blank" title="分享到微信" href="https://chart.apis.google.com/chart?cht=qr&amp;chs=300x300&amp;chl=https%3A%2F%2Fluowei.github.io%2Flist%2Fdocs%2Fweb%2F2016-05-12-HTTPS%25E7%259A%2584%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3.html"><i class="icon-large icon-wechat"></i></a> <a class="weibo" target="_blank" title="分享到微博" href="http://service.weibo.com/share/share.php?title=HTTPS的深入理解 - 知不知&amp;url=https%3A%2F%2Fluowei.github.io%2Flist%2Fdocs%2Fweb%2F2016-05-12-HTTPS%25E7%259A%2584%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3.html&amp;type=3&amp;searchPic=1"><i class="icon-large icon-weibo"></i></a> <a class="qzone" target="_blank" title="分享到 QQ 空间" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https%3A%2F%2Fluowei.github.io%2Flist%2Fdocs%2Fweb%2F2016-05-12-HTTPS%25E7%259A%2584%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3.html&amp;title=HTTPS的深入理解 - 知不知&amp;summary=HTTPS的深入理解&amp;site=/list"><i class="icon-large icon-qzone"></i></a> <a class="twitter" target="_blank" title="Share to Twitter" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fluowei.github.io%2Flist%2Fdocs%2Fweb%2F2016-05-12-HTTPS%25E7%259A%2584%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3.html&amp;text=HTTPS的深入理解 - 知不知&amp;via=luowei010101"><i class="icon-large icon-twitter"></i></a> <a class="facebook" target="_blank" title="Share to Facebook" href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Fluowei.github.io%2Flist%2Fdocs%2Fweb%2F2016-05-12-HTTPS%25E7%259A%2584%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3.html&amp;t=HTTPS的深入理解 - 知不知"><i class="icon-large icon-facebook-sign"></i></a> <a class="googleplus" target="_blank" title="Share to Google+" href="https://plus.google.com/share?url=https%3A%2F%2Fluowei.github.io%2Flist%2Fdocs%2Fweb%2F2016-05-12-HTTPS%25E7%259A%2584%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3.html"><i class="icon-large icon-google-plus-sign"></i></a> </span> </div> <hr /> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" /> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <div id="gitalk-container"></div> <script type="text/javascript"> var gitalk = new Gitalk({ clientID: '9d5ee666269c252cf949', clientSecret: '728cd598f1fca9d8c1df1dfa300057883a3a8676', repo: 'list', owner: 'luowei', admin: ['luowei'], id: decodeURI('HTTPS的深入理解'), distractionFreeMode: false }); gitalk.render('gitalk-container'); </script> <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277627361'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s96.cnzz.com/z_stat.php%3Fid%3D1277627361%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script> <footer class="site-footer"> <span class="site-footer-owner"><a href="https://luowei.github.io/list">知不知</a> is maintained by <a href="http://luowei.github.io/list">luowei</a>.</span> <span class="site-footer-credits">Developed by <a href="https://luowei.github.io">luowei</a>.</span> </footer> </section> </body> </html>
