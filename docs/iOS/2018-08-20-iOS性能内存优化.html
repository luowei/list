<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>知不知</title> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="theme-color" content="#157878"> <link rel="stylesheet" href="/list/assets/css/normalize.css"> <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'> <link rel="stylesheet" href="/list/assets/css/cayman.css"> </head> <body> <section class="page-header"> <h1 class="project-name">知不知</h1> <h2 class="project-tagline"><a style="color:#ffffff;" href="http://luowei.github.io/list">知不知</a> 是一个代码爱好者的技术知识分享部落格。</h2> <a href="http://wodedata.com" target="_blank" class="btn">wodedata</a> <a href="/list" class="btn">home</a> <a href="http://app.wodedata.com" target="_blank" class="btn">APP作品</a> </section> <section class="main-content"> <!-- 标题 --> <h2>iOS性能内存优化</h2> <!-- Google Ads --> <script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8760692904992206" data-ad-slot="2948937366"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script></p> <p><strong>iOS性能内存优化</strong></p> <ul> <li>几个优化总体思路： <ul> <li>避免过多的CPU计算 <ul> <li>简化复杂频繁的布局计算</li> <li>文本计算、格式转换、图像绘制、对象的创建调整等尽可能放到后台线程进行</li> </ul> </li> <li>避免图层混合 <ul> <li>确保控件的opaque属性设置为true，确保backgroundColor和父视图颜色一致且不透明</li> <li>如无特殊需要，不要设置低于1的alpha值</li> <li>确保UIImage没有alpha通道</li> </ul> </li> <li>避免临时转换 <ul> <li>确保图片大小和frame一致，不要在滑动时缩放图片</li> <li>确保图片颜色格式被GPU支持，避免劳烦CPU转换</li> </ul> </li> <li>慎用离屏渲染 <ul> <li>绝大多数时候离屏渲染会影响性能</li> <li>重写drawRect方法，设置圆角、阴影、模糊效果，光栅化都会导致离屏渲染</li> <li>设置阴影效果是加上阴影路径</li> <li>滑动时若需要圆角效果，开启光栅化</li> </ul> </li> </ul> </li> </ul> <hr /> <ul> <li>屏幕显示图像的原理 <ul> <li>CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync信号(垂直同步信号)逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</li> <li>显示系统一般都是双缓冲机制，即引入两个缓冲区。GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。这样对帧缓冲区的读取和刷新的效率会较大提升。</li> <li>双缓冲又可能会带来画面撕裂的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，就造成画面撕裂现象。</li> <li>多双缓冲区为了解决画面撕裂的问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</li> <li>iOS 设备会始终使用双缓存，并开启垂直同步。而安卓设备直到 4.1 版本，Google 才开始引入这种机制，目前安卓系统是三缓存+垂直同步。</li> </ul> </li> <li>卡顿产生的原因和解决方案 <ul> <li>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。</li> <li>随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。</li> <li>由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。所以CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。</li> </ul> </li> </ul> <hr /> <ul> <li>CPU 资源消耗原因和解决方案 <ul> <li>布局计算。 <ul> <li>视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局、并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</li> <li>不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</li> <li>Autolayout。Autolayout对于复杂视图来说常常会产生严重的性能问题。随着视图数量、层次的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。当然可以使用 ComponentKit、AsyncDisplayKit 等框架替代解决。</li> </ul> </li> <li>文本计算。 <ul> <li>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。</li> <li>如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</li> </ul> </li> <li>文本渲染。 <ul> <li>屏幕上能看到的所有文本内容控件，包括 UIWebView，在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。常见的文本控件 （UILabel、UITextView 等），其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。</li> <li>对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</li> </ul> </li> <li>图片的解码。 <ul> <li>原理：像素在内存中的布局和它在磁盘中的存储方式并不相同，每个像素有R、G、B和alpha四个值，每个值占用1字节，因此每个像素占用4字节的内存空间。一张1920*1080的照片(iPhone6 Plus的分辨率)一共有2,073,600个像素，因此占用了超过8Mb的内存。但是一张同样分辨率的PNG格式或JPEG格式的图片一般情况下不会有这么大。这是因为JPEG将像素数据进行了一种非常复杂且可逆的转化。</li> <li>解码过程： 当我们打开JPEG格式的图片时，CPU会进行一系列解码相关运算，将JPEG图片解压成像素数据。显然这个工作会消耗不少时间，所以不应该在滑动时进行，我们应该预先处理好图片。</li> <li>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。</li> <li>如果想要绕开这个机制，就需要预先处理好图片格式的转换。常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</li> </ul> </li> <li>图像的绘制。 <ul> <li>图片都需要被缩放</li> <li> <p>图像的绘制通常是指用那些以 CG 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  - (void)display {
      dispatch_async(backgroundQueue, ^{
          CGContextRef ctx = CGBitmapContextCreate(...);
          // draw in context...
          CGImageRef img = CGBitmapContextCreateImage(ctx);
          CFRelease(ctx);
          dispatch_async(mainQueue, ^{
              layer.contents = img;
          });
      });
  }
</code></pre></div> </div> </li> </ul> </li> <li>对象创建。对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。比如 CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。 <ul> <li>如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。</li> <li>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。</li> <li>如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</li> <li>通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多。</li> </ul> </li> <li>对象调整。对象的调整也经常是消耗 CPU 资源的地方。 <ul> <li>这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。U</li> <li>IView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</li> <li>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</li> </ul> </li> <li>对象销毁。对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。</li> </ul> </li> </ul> <hr /> <ul> <li> <p>GPU 资源消耗原因和解决方案</p> <p>相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形），应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</p> <ul> <li> <p><strong>避免短时间内大量图片的显示。</strong>纹理的渲染，所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能<strong>将多张图片合成为一张进行显示</strong>。</p> </li> <li> <p><strong>避免图片过大。</strong>超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096x4096。所以，尽量不要让图片和视图的大小超过这个值。</p> </li> <li> <p><strong>避免不必要的缩放。</strong>在给UIImageView设置图片时，应尽可能保证无论是本地图片还是从网络或取得图片的大小，都与其frame保持一致，因为图片的缩放需要占用CPU时间的。</p> </li> <li><strong>避免图层的混合 (Composing)。</strong>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗，应用应当尽量减少视图数量和层次，并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。如果只想显示最上层的图层，可以把它的透明度设置为100%，这样GPU会忽略下面所有的layer，从而节约了很多不必要的运算。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。 <ul> <li>UIView的opaque属性默认值就是true，也就是说只要不是人为设置成透明，都不会出现图层混合。</li> <li>对于UIImageView来说，不仅它自身需要是不透明的，它的图片也不能含有alpha通道。</li> <li>还有一个更重要的是backgroundColor属性，如果不设置这个属性，控件依然被认为是透明的。所以可以在控件init的时候给<code class="highlighter-rouge">backgroundColor</code>设置一个不透明的颜色。</li> <li>具体做法： <ul> <li>确保控件的opaque属性设置为true，确保backgroundColor和父视图颜色一致且不透明。</li> <li>如无特殊需要，不要设置低于1的alpha值。</li> <li>确保UIImage没有alpha通道。</li> </ul> </li> </ul> </li> <li><strong>避免反复的离屏渲染。</strong>CALayer 的 border、圆角、阴影、遮罩（mask），CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering），而离屏渲染通常发生在 GPU 中。 <ul> <li>当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。</li> <li>对于只需要圆角的某些场合，更高效的做法是可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</li> </ul> </li> <li><strong>缩小重绘区域。</strong>刷新视图时，我们应该把需要重绘的区域尽可能缩小。对于未发生变化的内容则不应该重绘。</li> </ul> </li> <li> <p>离屏渲染</p> <ul> <li>离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。</li> <li>当设置了以下属性时，会触发离屏渲染： <ul> <li>重写drawRect方法</li> <li>开发光栅化shouldRasterize（光栅化）</li> <li>masks、layer.masksToBounds以模糊效果（遮罩）</li> <li>shadows或是layer.shadow（阴影）</li> <li>edge antialiasing（抗锯齿）</li> <li>group opacity（组透明）</li> </ul> </li> <li>光栅化，光栅化是将一个layer预先渲染成位图(bitmap)，然后加入缓存中。如果对于阴影效果这样比较消耗资源的静态内容进行缓存，可以得到一定幅度的性能提升。</li> <li>离屏渲染耗时的原因主要有创建缓冲区和上下文切换。 <ul> <li>上下文切换，首先要保存当前屏幕渲染环境，然后切换到一个新的绘制环境，申请绘制资源，初始化环境，然后开始一个绘制，绘制完毕后销毁这个绘制环境，如需要切换到主屏渲染或者再开始一个新的离屏渲染，则又要重复之前的操作。</li> <li>不要在滚动视图使用cornerRadius或者mask，如果非要如此，可以开启光栅化<code class="highlighter-rouge">shouldRasterize = YES</code>会使视图渲染内容被缓存起来，下次绘制的时候可以直接显示缓存。</li> </ul> </li> <li></li> </ul> </li> </ul> <hr /> <p>以上参考：</p> <p><a href="https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Performance.html">离屏渲染</a></p> <p><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></p> <p><a href="http://www.cnblogs.com/tanzhenblog/p/5001344.html">iOS性能优化之内存管理：Analyze、Leaks、Allocations的使用和案例代码</a></p> <p><a href="http://www.jianshu.com/p/619cf14640f3">UIKit性能调优实战讲解</a></p> <p><a href="http://www.cocoachina.com/ios/20150803/12873.html">小心别让圆角成了你列表的帧数杀手</a></p> <p><span class="site-footer-credits">版权所有，转载请注明出处 <a href="https://luowei.github.io/list">luowei.github.io</a>.</span></p> <link rel="stylesheet" href="/list/assets/css/font-awesome.min.css?ver=20151122" /> <!--[if IE 7 ]><link rel="stylesheet" href="/list/assets/css/font-awesome-ie7.min.css?ver=20151122"><![endif]--> <div style="float: right"> <span id="share"> <a class="wechat" target="_blank" title="分享到微信" href="https://chart.apis.google.com/chart?cht=qr&amp;chs=300x300&amp;chl=/list/docs/iOS/2018-08-20-iOS%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96.html"><i class="icon-large icon-wechat"></i></a> <a class="weibo" target="_blank" title="分享到微博" href="http://service.weibo.com/share/share.php?title=iOS性能内存优化 - 知不知&amp;url=/list/docs/iOS/2018-08-20-iOS%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96.html&amp;type=3&amp;searchPic=1"><i class="icon-large icon-weibo"></i></a> <a class="qzone" target="_blank" title="分享到 QQ 空间" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=/list/docs/iOS/2018-08-20-iOS%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96.html&amp;title=iOS性能内存优化 - 知不知&amp;summary=iOS性能优化、内存优化&amp;site=/list"><i class="icon-large icon-qzone"></i></a> <a class="twitter" target="_blank" title="Share to Twitter" href="https://twitter.com/intent/tweet?url=/list/docs/iOS/2018-08-20-iOS%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96.html&amp;text=iOS性能内存优化 - 知不知&amp;via=luowei010101"><i class="icon-large icon-twitter"></i></a> <a class="facebook" target="_blank" title="Share to Facebook" href="https://www.facebook.com/sharer.php?u=/list/docs/iOS/2018-08-20-iOS%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96.html&amp;t=iOS性能内存优化 - 知不知"><i class="icon-large icon-facebook-sign"></i></a> <a class="googleplus" target="_blank" title="Share to Google+" href="https://plus.google.com/share?url=/list/docs/iOS/2018-08-20-iOS%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96.html"><i class="icon-large icon-google-plus-sign"></i></a> </span> </div> <hr /> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" /> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <div id="gitalk-container"></div> <script type="text/javascript"> var gitalk = new Gitalk({ clientID: '9d5ee666269c252cf949', clientSecret: '728cd598f1fca9d8c1df1dfa300057883a3a8676', repo: 'list', owner: 'luowei', admin: ['luowei'], id: decodeURI('iOS性能内存优化'), distractionFreeMode: false }); gitalk.render('gitalk-container'); </script> <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277627361'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s96.cnzz.com/z_stat.php%3Fid%3D1277627361%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script> <footer class="site-footer"> <span class="site-footer-owner"><a href="">知不知</a> is maintained by <a href="http://luowei.github.io/list">luowei</a>.</span> <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</span> </footer> </section> </body> </html>
