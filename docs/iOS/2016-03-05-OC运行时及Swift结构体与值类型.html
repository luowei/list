<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8"> <title>知不知</title> <meta name="viewport" content="width=device-width, initial-scale=1"> <meta name="theme-color" content="#157878"> <meta name="apple-itunes-app" content="app-id=1227288468, app-argument=https://luowei.github.io/list/docs/iOS/2016-03-05-OC%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%8ASwift%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8E%E5%80%BC%E7%B1%BB%E5%9E%8B.html"> <link rel="stylesheet" href="/list/assets/css/normalize.css"> <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'> <link rel="stylesheet" href="/list/assets/css/cayman.css"> </head> <body> <section class="page-header"> <h1 class="project-name">知不知</h1> <h2 class="project-tagline"><a style="color:#ffffff;" href="http://luowei.github.io/list">知不知</a> 是一个代码爱好者的技术知识分享部落格。</h2> <a href="http://wodedata.com" target="_blank" class="btn">wodedata</a> <a href="/list" class="btn">home</a> <a href="http://app.wodedata.com" target="_blank" class="btn">APP作品</a> </section> <section class="main-content"> <!-- 标题 --> <h2>OC运行时及Swift结构体与值类型</h2> <!-- Google Ads --> <script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <p><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-8760692904992206" data-ad-slot="2948937366"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script></p> <p><strong>OC中的运行时</strong></p> <ul> <li> <p>OC本身是一种强类型语言，但其运行时功能让它又有了动态语言的特点。OC中对象的类型和对象所执行的方法都是在运行时阶段进行查找并确认的，这种机制被称为动态绑定。</p> </li> <li> <p>在很多语言，比如 C ，调用一个方法其实就是跳到内存中的某一点并开始执行一段代码。没有任何动态的特性，因为这在编译时就决定好了。而在 Objective-C 中，[object foo] 语法并不会立即执行 foo 这个方法的代码。它是在运行时给 object 发送一条叫 foo 的消息。这个消息，也许会由 object 来处理，也许会被转发给另一个对象，或者不予理睬假装没收到这个消息。多条不同的消息也可以对应同一个方法实现。这些都是在程序运行的时候决定的。</p> </li> <li> <p>Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。</p> </li> <li> <p>OC是C语言的超集，所以OC中面向对象的功能在底层也是使用C语言来实现，是通过引入特有的运行时库，形成一门支持面向对象特性的语言。即一个动态链接库——libobjc.A.dylib。这个动态库里面提供了Objective-C语言所需的各种动态特性。</p> </li> <li> <p>想要支持运行时多态，代码中一定包含有运行时所需的判断数据。Java的运行时信息都在.class文件中按规范格式保留下来；编译后的C++代码也一样保有RTTI，而Objective-C代码中的运行时信息都保留在编译过后的目标文件中（.o）。</p> </li> <li> <p>在OC中，由于动态绑定机制使得程序直到运行时才能清楚那个方法需要被执行，甚至通过使用底层的运行时函数，就可以更改调用的方法或改变方法内部的功能实现，这些特性使得OC成为一门真正的动态语言。</p> </li> <li> <p>objc_msgSend是一个可变参数函数，其中第一个参数代表消息的接收者，第二个参数代表消息的选择器，后续参数表示消息发送时附带的参数。编译器在编译期间就会将发送消息的代码转换为objc_msgSend函数。</p> </li> <li> <p>消息传递</p> <ul> <li>在编译时你写的 Objective-C 函数调用的语法都会被翻译成一个 C 的函数调用 - objc_msgSend() 。比如，下面两行代码就是等价的：</li> </ul> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  [array insertObject:foo atIndex:5];
  objc_msgSend(array, @selector(insertObject:atIndex:), foo, 5);
</code></pre></div> </div> <ul> <li>消息传递的关键藏于 objc_object 中的 isa 指针和 objc_class 中的class dispatch table。objc_object,objc_class以及Ojbc_method。在 Objective-C 中，类、对象和方法都是一个 C 的结构体，从 objc/objc.h 头文件中，我们可以找到他们的定义:</li> </ul> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  struct objc_object {  
      Class isa  OBJC_ISA_AVAILABILITY;
  };
    
  struct objc_class {  
      Class isa  OBJC_ISA_AVAILABILITY;
  #if !__OBJC2__
      Class super_class;
      const char *name;
      long version;
      long info;
      long instance_size;
      struct objc_ivar_list *ivars;
      **struct objc_method_list **methodLists**;
      **struct objc_cache *cache**;
      struct objc_protocol_list *protocols;
  #endif
  };
    
  struct objc_method_list {  
      struct objc_method_list *obsolete;
      int method_count;
    
  #ifdef __LP64__
      int space;
  #endif
    
      /* variable length structure */
      struct objc_method method_list[1];
  };
    
  struct objc_method {  
      SEL method_name;
      char *method_types;    /* a string representing argument/return types */
      IMP method_imp;
  };
</code></pre></div> </div> <ul> <li>发送一条消息也就 objc_msgSend 做了什么事。举 objc_msgSend(obj, foo) 这个例子来说： <ol> <li>首先，通过 obj 的 isa 指针找到它的 class ;</li> <li>在 class 的 method list 找 foo ;</li> <li>如果 class 中没到 foo，继续往它的 superclass 中找 ;</li> <li>一旦找到 foo 这个函数，就去执行它的实现IMP .</li> </ol> </li> </ul> </li> <li>Message Forward 消息转发： <ul> <li>当消息派发流程最终在对象的类和父类中都没有找到对应选择器的方法时，就会开启消息转发流程。</li> <li>首先，第一步会先调用消息接收者所在类的<code class="highlighter-rouge">resolveInstanceMethod:</code>方法，该方法返回一个BOOL值，表示是否动态添加一个方法来响应当前消息选择器。如果发送的消息是一个类方法，则会调用另一个类似的方法<code class="highlighter-rouge">resolveClassMethod:</code>。</li> <li>消息接收者所在类重写了<code class="highlighter-rouge">resolveInstanceMethod:</code>方法并返回YES，也就意味着想要动态添加一个方法来响应当前的消息选择器，可以在重写的方法内使用<code class="highlighter-rouge">class_addMethod</code>函数来为当前类添加方法。</li> <li>如果上面过程中，并没有新方法能响应消息选择器，则会进入消息转发流程的第二步。在第二步中系统会调用当前消息接收者所在类的<code class="highlighter-rouge">forwardingTargetForSelector:</code>方法，用以询问能否将该条消息发送给其他接收者来处理，方法的返回值就代表这个新的接收者，如果不允许将消息转发给其他接收者则返回nil。</li> <li>如果<code class="highlighter-rouge">forwardingTargetForSelector:</code>方法的返回值为nil，那么消息转发机制还要继续进行最后一步。在这一步中，系统会将尚未处理的消息包装成一个NSInvocation对象，其内部包含与该消息相关的所有信息，比如消息的选择器、目标接收者、参数等。之后系统会调用消息接收者所在类的<code class="highlighter-rouge">forwardInvocation:</code>方法，并将生成的NSInvocation对象作为参数传入。</li> </ul> </li> <li>Method Swizzing 方法调配 <ul> <li>OC中方法和消息选择器之间的关系,在运行时头文件中，我们可以找到方法的底层结构定义;</li> </ul> <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  struct objc_method {
      SEL method_name;
      char *method_types;
      IMP method_imp;
  }
</code></pre></div> </div> <ul> <li> <p>可以看出，每一个方法内部都包含三个成员，第一个是选择器代表方法的名字，第二个是方法的类型，其值是一个C语言字符串，可以参考前文讲过类型编码，最后一个是C语言中的函数指针，用以指向方法具体执行的函数。我们可以把方法的内部结构理解为每一个SEL选择器（可以当做是方法名）对应一个具体的IMP函数（可以当做是方法的实现），这也是SEL被称为选择器的原因。这样我们就可以更加清楚地理解消息派发时，系统是如何根据消息选择器来查找对应的方法并跳转到方法的具体实现的了。</p> </li> <li> <p>因为消息选择器和方法实现之间的一对一关系后，我们接下来开始介绍方法调配技术，它其实就是利用运行时提供的函数来动态修改选择器和方法实现之间的对应关系的一种技术。利用这种技术，我们可以在运行时为某个类添加选择器或更改选择器所对应的方法实现</p> </li> </ul> </li> </ul> <hr /> <p>以上参考： <a href="http://wxgbridgeq.github.io/blog/2015/07/09/effective-oc-note-second/">理解OC运行时</a> <a href="http://www.molotang.com/articles/1912.html">Objective-C的对象模型与运行时</a> <a href="http://tech.glowing.com/cn/objective-c-runtime/">Objective-C Runtime</a></p> <hr /> <p><strong>Swift中的结构体及值类型</strong></p> <ul> <li>相同点 <ul> <li>Swift中的类和结构体非常类似，都具有定义和使用属性、方法、下标和构造器、扩展、符号协议等面向对象特性。</li> </ul> </li> <li>不同点 <ul> <li>但是结构体不具有继承性、运行时强制类型转换、使用析构器和使用引用计数的多次引用等能力。</li> <li>Swift中只有类是引用类型，其他类型全部是值类型（整型、浮点型、布尔型、字符串、元组、集合、枚举以及函数类型、闭包类型）。</li> </ul> </li> <li>值类型的优势与使用场景 <ul> <li>默认情况下，值类型被强制使用或者至少说被鼓励使用在属性上，来使得工作更清晰。</li> <li>值类型是稳定的，值类型不具有行为，它是非常稳定的。虽然其中的一些方法可能会使值类型本身发生改变，但是控制流却还是严格地受控于该实例的唯一所有者。</li> <li>一个典型的值类型对任何外部组件的行为都没有隐式的依赖。它是孤立的。</li> <li>值类型是可交换的，因为每次将值类型赋给一个新变量的时候，该值类型都是被复制的，所以，所有的这些副本都是可交换的。</li> <li>值层 (value layer) 实际上没有状态；它仅仅用来表示和变换数据。</li> <li>对象可以和其他对象通信，但是通常它们发送的是值，而不是引用，除非它们确实想要和外部不可或缺的层创建一个持久的连接。</li> </ul> </li> </ul> <hr /> <p>以上参考了：<br /> <a href="https://www.objccn.io/issue-16-2/">结构体和值类型</a><br /> <a href="http://www.cnblogs.com/chebaodaren/p/5590994.html">Swift - 类和结构体</a><br /> <a href="http://swift.gg/2015/10/20/thinking-in-swift-3/">Swift 编程思想，第三部分：结构体和类</a></p> <p><span class="site-footer-credits">版权所有，转载请注明出处 <a href="https://luowei.github.io/list">luowei.github.io</a>.</span></p> <link rel="stylesheet" href="/list/assets/css/font-awesome.min.css?ver=20151122" /> <!--[if IE 7 ]><link rel="stylesheet" href="/list/assets/css/font-awesome-ie7.min.css?ver=20151122"><![endif]--> <div style="float: right"> <span id="share"> <a class="wechat" target="_blank" title="分享到微信" href="https://chart.apis.google.com/chart?cht=qr&amp;chs=300x300&amp;chl=https%3A%2F%2Fluowei.github.io%2Flist%2Fdocs%2FiOS%2F2016-03-05-OC%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E5%258F%258ASwift%25E7%25BB%2593%25E6%259E%2584%25E4%25BD%2593%25E4%25B8%258E%25E5%2580%25BC%25E7%25B1%25BB%25E5%259E%258B.html"><i class="icon-large icon-wechat"></i></a> <a class="weibo" target="_blank" title="分享到微博" href="http://service.weibo.com/share/share.php?title=OC运行时及Swift结构体与值类型 - 知不知&amp;url=https%3A%2F%2Fluowei.github.io%2Flist%2Fdocs%2FiOS%2F2016-03-05-OC%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E5%258F%258ASwift%25E7%25BB%2593%25E6%259E%2584%25E4%25BD%2593%25E4%25B8%258E%25E5%2580%25BC%25E7%25B1%25BB%25E5%259E%258B.html&amp;type=3&amp;searchPic=1"><i class="icon-large icon-weibo"></i></a> <a class="qzone" target="_blank" title="分享到 QQ 空间" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https%3A%2F%2Fluowei.github.io%2Flist%2Fdocs%2FiOS%2F2016-03-05-OC%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E5%258F%258ASwift%25E7%25BB%2593%25E6%259E%2584%25E4%25BD%2593%25E4%25B8%258E%25E5%2580%25BC%25E7%25B1%25BB%25E5%259E%258B.html&amp;title=OC运行时及Swift结构体与值类型 - 知不知&amp;summary=OC中的运行时及Swift中的结构体及值类型&amp;site=/list"><i class="icon-large icon-qzone"></i></a> <a class="twitter" target="_blank" title="Share to Twitter" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fluowei.github.io%2Flist%2Fdocs%2FiOS%2F2016-03-05-OC%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E5%258F%258ASwift%25E7%25BB%2593%25E6%259E%2584%25E4%25BD%2593%25E4%25B8%258E%25E5%2580%25BC%25E7%25B1%25BB%25E5%259E%258B.html&amp;text=OC运行时及Swift结构体与值类型 - 知不知&amp;via=luowei010101"><i class="icon-large icon-twitter"></i></a> <a class="facebook" target="_blank" title="Share to Facebook" href="https://www.facebook.com/sharer.php?u=https%3A%2F%2Fluowei.github.io%2Flist%2Fdocs%2FiOS%2F2016-03-05-OC%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E5%258F%258ASwift%25E7%25BB%2593%25E6%259E%2584%25E4%25BD%2593%25E4%25B8%258E%25E5%2580%25BC%25E7%25B1%25BB%25E5%259E%258B.html&amp;t=OC运行时及Swift结构体与值类型 - 知不知"><i class="icon-large icon-facebook-sign"></i></a> <a class="googleplus" target="_blank" title="Share to Google+" href="https://plus.google.com/share?url=https%3A%2F%2Fluowei.github.io%2Flist%2Fdocs%2FiOS%2F2016-03-05-OC%25E8%25BF%2590%25E8%25A1%258C%25E6%2597%25B6%25E5%258F%258ASwift%25E7%25BB%2593%25E6%259E%2584%25E4%25BD%2593%25E4%25B8%258E%25E5%2580%25BC%25E7%25B1%25BB%25E5%259E%258B.html"><i class="icon-large icon-google-plus-sign"></i></a> </span> </div> <hr /> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" /> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <div id="gitalk-container"></div> <script type="text/javascript"> var gitalk = new Gitalk({ clientID: '9d5ee666269c252cf949', clientSecret: '728cd598f1fca9d8c1df1dfa300057883a3a8676', repo: 'list', owner: 'luowei', admin: ['luowei'], id: decodeURI('OC运行时及Swift结构体与值类型'), distractionFreeMode: false }); gitalk.render('gitalk-container'); </script> <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1277627361'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s96.cnzz.com/z_stat.php%3Fid%3D1277627361%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));</script> <footer class="site-footer"> <span class="site-footer-owner"><a href="https://luowei.github.io/list">知不知</a> is maintained by <a href="http://luowei.github.io/list">luowei</a>.</span> <span class="site-footer-credits">Developed by <a href="https://luowei.github.io">luowei</a>.</span> </footer> </section> </body> </html>
